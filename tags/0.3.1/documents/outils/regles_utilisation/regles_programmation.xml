<?xml version='1.0'?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN" "http://www.oasis-open.org/docbook/xml/4.2/docbookx.dtd">
<article>

  <title>Règles de programmations du Projet Univers</title>

  <articleinfo>

    <orgname>Equipe du Projet Univers</orgname>
    <author>

      <personname><firstname>Mathieu</firstname><surname>Roger</surname></personname>
      <email>rogmaboami@hotmail.com</email>

    </author>

    <revhistory>

      <revision><revnumber>0.1</revnumber><date>11 mars 
      2004</date><revdescription><para>Création 
      initiale</para></revdescription></revision>

      <revision><revnumber>0.2</revnumber><date>1 mai 
      2004</date><revdescription><para>Restructuration, ajout 
      d&apos;exemples et de règles.</para></revdescription></revision>

      <revision><revnumber>0.3</revnumber><date>29 août 
      2004</date><revdescription><para>Corrections 
      diverses.</para><para>Clarification de la partie sur 
      l&apos;arborescence des 
      fichiers.</para></revdescription></revision>

      <revision><revnumber>0.4</revnumber><date>30 mars 
      2005</date><revdescription><para>Ajout de 
      eclipse</para><para>Passage de Cocoon à 
      Doxygen</para></revdescription></revision>

    </revhistory>

    <legalnotice>

      <para>Ce document est sous license 
      <ulink url="http://www.gnu.org/copyleft/fdl.html">GNU Free 
      Documentation License</ulink></para>

    </legalnotice>

    <abstract>

      <para>Ce document décrit les règles que doivent suivrent les 
      codes soure du Projet Univers.</para>

    </abstract>

  </articleinfo>

  <sect1>

    <title>Objectif du document</title>

    <para>Le but de ce document est de définir précisément les règles à 
    respecter durant la programmation du projet Univers. Cependant ces 
    règles peuvent parfaitement être utilisées pour d&apos;autres 
    projets.</para>

    <para>L&apos;écriture d&apos;un projet par plusieurs programmeurs 
    nécessite l&apos;explicitation et le respect de règles. Les 
    avantages sont nombreux :</para>

    <itemizedlist>

      <listitem>

        <para>guider la façon dont est ecrit le code source</para>

      </listitem>

      <listitem>

        <para>faciliter la compréhension d&apos;un code source écrit 
        par un autre membre de l&apos;équipe de développement</para>

      </listitem>

      <listitem>

        <para>améliorer la qualité du code en empêchant certaines 
        pratiques, légales du point de vue du langage de programmation, 
        mais dangereuses car produisant généralement des erreurs</para>

      </listitem>

      <listitem>

        <para>faciliter l&apos;intégration de nouveaux développeurs à 
        l&apos;équipe de développement</para>

      </listitem>

    </itemizedlist>

    <para>Ces règles peuvent être vérifiées par plusieurs moyens 
    :</para>

    <itemizedlist>

      <listitem>

        <para>Par le compilateur C++ lui même. Ce sera le cas pour 
        certaines règles, notamment celles concernant la gestion de la 
        mémoire.</para>

      </listitem>

      <listitem>

        <para>Par un vérificateur externe. Ce sera le cas pour 
        certaines règles, par exemple pour la règle qui dit qu&apos;une 
        classe abstraite possède obligatoirement un destructeur 
        virtuel.</para>

      </listitem>

    </itemizedlist>

    <para>Tout programme qui ne vérifiera pas ces règles sera rejetté 
    et ce rejet sera signifié au développeur qui a violé la ou les 
    règles. Idéalement, les règles transgréssées sont signalées au 
    programmeur.</para>

    <para>La procédure d&apos;acceptation d&apos;une modification de 
    code source est donc la suivante :</para>

    <procedure><step><para>Le code source modifié est envoyé par le 
    programmeur à un responsable de développement</para></step>
    <step><para>Le responsalbe de développement vérifie que les règles 
    sont respectées.</para><para>Si ce n&apos;est pas le cas, 
    l&apos;echec est signifié au programmeur et la procédure 
    s&apos;arrête.</para></step><step><para>Le responsable de 
    développement vérifie que les tests unitaires sont 
    satisfaits.</para><para>Si ce n&apos;est pas le cas, l&apos;echec 
    est signifié au programmeur et la procédure 
    s&apos;arrête.</para></step><step><para>Le code source est mis dans 
    la base de code source.</para></step></procedure>
  </sect1>

  <sect1>

    <title>Définitions</title>

    <para>Les différents genres de classes et de types C++ utilisées 
    dans le projet sont les suivants.</para>

    <sect2>

      <title>Classes de valeurs</title>

      <para>Une classe de valeurs est une classe qui possède un 
      constructeur de copie, une surcharge de l&apos;opérateur 
      d&apos;affectation et de l&apos;opérateur de comparaison. </para>

      <para>Les objets C++ d&apos;une classe de valeurs sont manipulée 
      par copie : il va exister plusieurs copie de la &quot;même&quot; 
      valeur. C&apos;est classiquement le cas des entiers : il existe 
      plusieurs copies du même entier.</para>

      <para>Les types prédéfinis sont tous des classes de valeurs (même 
      si en fait, ils ne sont pas forcement représentés par des 
      classes, mais parfois par des types).</para>

      <para>Les types prédéfinis sont :</para>

      <itemizedlist>

        <listitem>

          <para>Entier</para>

        </listitem>

        <listitem>

          <para>Reel</para>

        </listitem>

        <listitem>

          <para>Booleen</para>

        </listitem>

        <listitem>

          <para>Caractere</para>

        </listitem>

        <listitem>

          <para>Chaine</para>

        </listitem>

        <listitem>

          <para>BooleenEtendu</para>

          <para>C&apos;ets le type des booléen {VRAI,FAUX, 
          PEUTETRE}</para>

        </listitem>

        <listitem>

          <para>EntierPositif</para>

          <para>C&apos;est le type des entiers positifs 0, 1, ...</para>

        </listitem>

      </itemizedlist>

      <example>

        <title>Exemple de classe de valeurs</title>

        <para>La classe des dates est ici une classe de valeurs.</para>

        <classsynopsis>
        <ooclass><classname>Date</classname></ooclass><methodsynopsis><methodname>Booleen 
        operator==</methodname><methodparam><parameter>const 
        Date&amp;</parameter></methodparam><modifier>const</modifier></methodsynopsis><methodsynopsis><methodname>Date</methodname>
        <methodparam><parameter>const 
        Date&amp;</parameter></methodparam></methodsynopsis><methodsynopsis><methodname>Date&amp; 
        operator=</methodname><methodparam><parameter>const 
        Date&amp;</parameter></methodparam></methodsynopsis></classsynopsis>
      </example>

      <para>Les classes de valeurs peuvent se trouver directement comme 
      type de variables, ou type d&apos;attributs.</para>

    </sect2>

    <sect2>

      <title>Classes d&apos;objets</title>

      <para>Une classe d&apos;objets est une classe C++ qui ne possède 
      pas de surcharge des opérateur d&apos;affectation ni de 
      comparaison.</para>

      <para>Les objets C++ d&apos;une classe d&apos;objet sont 
      manipulés par pointeur, cela permet à plusieurs objets C++ de 
      référencer le même objet. Ceci implique une chose : tous ceux qui 
      référencent un objet verront tous les modifications que subit cet 
      objet.</para>

      <para>Les classes d&apos;objets ne se trouvent pas directement 
      utilisés comme types de variables, d&apos;attributs ou comme 
      paramètres de méthodes.</para>

      <sect3>

        <title>Classes abstraites d&apos;objets</title>

        <para>Une classe abstraite est une classe qui contient au moins 
        une méthode virtuelle pure.</para>

      </sect3>

      <sect3>

        <title>Classes concrètes d&apos;objets</title>

        <para>Une classe est concrète si elle possède un constructeur 
        public.</para>

      </sect3>

    </sect2>

  </sect1>

  <sect1>

    <title>Règles de programmation</title>

    <para>Ces règles s&apos;appliquent aux codes sources du 
    projet.</para>

    <sect2>

      <title>Optimisation</title>

      <para>L&apos;optimisation se fait en dernier, la première étape 
      est de produire un code qui marche et qui soit clair. Dites vous 
      toujours que si le code est clair et que vous définissez des 
      classes quitte à ce que ce soient un nouveau nom pour des 
      entiers, alors il sera d&apos;autant plus facile d&apos;optimiser 
      plus tard. </para>

      <para>L&apos;optimisation n&apos;est pas l&apos;objectif, il ne 
      faut donc pas chercher à optimiser.</para>

      <example>

        <title>Exemple</title>

        <para>Objectif : On veut se doter d&apos;éléments qui symbolise 
        des moments (ou des instants) dans un monde.</para>

        <informalexample>

          <para>Ce qu&apos;il ne faut pas faire : coder ces moments par 
          des entiers.</para>

        </informalexample>

        <informalexample>

          <para>Ce qu&apos;il faut faire : créer une classe Moment, 
          quitte à mettre un entier dedans. Plus tard, on pourra faire 
          des optimisations spécifiques, en remplaçant l&apos;entier 
          par d&apos;autre choses.</para>

        </informalexample>

      </example>

    </sect2>

    <sect2>

      <title>Les noms des fichiers et répertoires</title>

      <para>Les noms des fichiers et des répertoires sont constitué de 
      caractères de lettres de <filename>a</filename> à <filename>
      z</filename> en minuscules et sans accents, si le nom doit être 
      composé de plusieurs mots ces mots sont séparés par le caractère 
      <filename>_</filename>.</para>

    </sect2>

    <sect2>

      <title>Organisation des fichiers et des répertoires</title>

      <para>L&apos;arborescence des répertoires et des fichiers sources 
      est de la forme suivante.</para>

      <para>Un répertoire racine <filename>sources</filename>.</para>

      <para>Ce répertoire contient ensuite des sous-répertoires qui 
      sont des deux types suivants :</para>

      <itemizedlist>

        <listitem>

          <para><link linkend="repertoire_application">Répertoire 
          d&apos;application</link></para>

        </listitem>

        <listitem>

          <para><link linkend="repertoire_module">Répertoire de 
          module</link></para>

        </listitem>

      </itemizedlist>

      <para>D&apos;une manière générale, il y a une correspondance 
      entre le chemin en dessous du répertoire source et le chemin des 
      namespaces C++. Le namespace global est ProjetUnivers.</para>

      <para>Chaque module correspond à un namespace C++, qui porte le 
      nom du module. Pour chaque module on se donne un deuxième niveau 
      de namespace correspondant à l&apos;implantation et au tests. En 
      fait les namespaces sont imbriqués de la même manière que 
      l&apos;arborescence des répertoires.</para>

      <sect3 id="repertoire_application">

        <title>Répertoire d&apos;application</title>

        <para>En dessous du répertoire sources, se trouvent les 
        répertoires de chaque application. Une application donne lieu à 
        un programme exécutable.</para>

        <para>Une application n&apos;a pas de namespace associé et une 
        application ne peut définir de classes ou procédures (sauf le 
        main).</para>

        <para>Un tel répertoire est appelé <glossterm>répertoire 
        d&apos;application</glossterm>.</para>

        <example>

          <title>Des répertoires d&apos;application</title>

          <itemizedlist>

            <listitem>

              <para>L&apos;application <application>Jeu</application> a 
              ses sources dans <filename>sources/jeu</filename>. Cette 
              application permet de jouer à Projet Univers.</para>

            </listitem>

            <listitem>

              <para>L&apos;application <application>
              EditeurMission</application> a ses sources dans <filename>
              sources/editeur_mission</filename>. Cette application 
              permet de construire des missions.</para>

            </listitem>

          </itemizedlist>

        </example>

        <para>Supposons que l&apos;application s&apos;appèle Xub, le 
        répertorie d&apos;application xub <emphasis>contient un seul 
        fichier</emphasis> :</para>

        <itemizedlist>

          <listitem>

            <para><filename>xub.cpp</filename></para>

          </listitem>

        </itemizedlist>

        <para>et les sous-répertoires suivant :</para>

        <itemizedlist>

          <listitem>

            <para><filename>test</filename></para>

            <para>pour contenir les programmes de tests, ce répertoire 
            est appelé <glossterm>répertoire des test de 
            <replaceable>Xub</replaceable></glossterm>.</para>

          </listitem>

          <listitem>

            <para><filename>implantation</filename></para>

            <para>pour contenir les différentes réalisations (i.e., 
            implantations), ce répertoire est appelé 
            <glossterm>répertoire des implantations de 
            <replaceable>Xub</replaceable></glossterm>.</para>

          </listitem>

        </itemizedlist>

      </sect3>

      <sect3 id="repertoire_module">

        <title>Répertoires de modules</title>

        <para><emphasis>Un répertoire de module ne contient que des 
        fichiers <filename>.h</filename>.</emphasis></para>

        <para>Un répertoire de module contient 
        <emphasis>obligatoirement</emphasis> les sous-répertoires 
        suivant :</para>

        <itemizedlist>

          <listitem>

            <para><filename>test</filename></para>

            <para>pour contenir les programmes de tests, placé dans le 
            module <replaceable>mod</replaceable>, ce répertoire est 
            appelé <glossterm>répertoire des test de 
            <replaceable>mod</replaceable></glossterm>.</para>

            <para>Le namespace correspondant est</para>

          </listitem>

          <listitem>

            <para><filename>implantation</filename></para>

            <para>pour contenir les différentes réalisations (i.e., 
            implantations) placé dans le module 
            <replaceable>mod</replaceable>, ce répertoire est appelé 
            <glossterm>répertoire des implantations de 
            <replaceable>mod</replaceable></glossterm>.</para>

          </listitem>

        </itemizedlist>

        <example>

          <title>Exemples de modules</title>

          <itemizedlist>

            <listitem>

              <para>Le répertoire du module réseau est : <filename>
              src/reseau</filename></para>

              <para>Le namespace correspondant est 
              <classname>ProjetUnivers::Reseau</classname>, i.e., deux 
              <token>namespaces</token> imbriqués.</para>

            </listitem>

          </itemizedlist>

        </example>

        <formalpara>

          <title>Explication</title>

          <para>Autant le sous répertoire test est devenu classique, 
          autant le répertoire implantation est moins courant. 
          L&apos;idée générale est d&apos;avoir une propriété qui est 
          trop rarement réalisée dans les bibliothèques de modules : 
          les modules doivent avoir une interface séparée de tout le 
          reste. La plupars des bibliothèques disponibles ont une 
          interface pour leurs modules, mais elles sont au mieux mélées 
          aux autres interfaces dans le répertoire include, et au pire 
          dans le même répertoire que leur implantation. Au final, les 
          quelques fichiers permettant d&apos;utiliser un module se 
          retrouvent mélé à d&apos;autres fichiers dont 
          l&apos;utilisateur du module n&apos;a que faire : et alors 
          tout devient plus compliqué.</para>

        </formalpara>

        <sect4>

          <title>Répertoire des implantation d&apos;application ou de 
          modules</title>

          <para>Un répertoire des implantation (d&apos;une application 
          ou d&apos;un module) peut contenir :</para>

          <itemizedlist>

            <listitem>

              <para>des fichiers <filename>.h</filename> et <filename>
              .cpp</filename></para>

              <para>De tels fichiers ne doivent pas dépendre d&apos;une 
              implantation spécifique, ce sont en quelque sorte les 
              facteurs communs des différentes implantations 
              possibles.</para>

              <para>Le namespace associé à ce niveau dans la hiérarchie 
              est 
              <classname>ProjetUnivers::LeNomDeLApplicationOuDuModule::Implantation</classname>.</para>

            </listitem>

            <listitem>

              <para>des répertoires, appelés <glossterm>répertoires 
              d&apos;implantation spécifique</glossterm>, i.e., il 
              s&apos;agit d&apos;un choix particulier 
              d&apos;implantation.</para>

              <para>Il peut y avoir plusieurs répertoires 
              d&apos;implantation spécifique, mais pendant la 
              compilation, un seul est utilisé. Un répertoire 
              d&apos;implantation spécifique peut contenir des fichiers 
              <filename>.h</filename> et <filename>
              .cpp</filename>.</para>

              <para><remark>Ceci a pour but de pouvoir tester plusieurs 
              implantations différentes pour un même 
              module.</remark></para>

            </listitem>

          </itemizedlist>

          <example>

            <title>Quelques exemples</title>

            <para>Pour le module Réseau on trouve plusieurs 
            implantations :</para>

            <itemizedlist>

              <listitem>

                <para>
                <filename>sources/reseau/implantation/client_serveur</filename></para>

                <para>qui contient une implantation du module Réseau 
                utilisant la technique du client serveur.</para>

                <para>Le namespace correspondant est 
                <classname>ProjetUnivers::Reseau::Implantation::ClientServeur</classname>.</para>

              </listitem>

              <listitem>

                <para>
                <filename>sources/reseau/implantation/distribue</filename></para>

                <para>qui contient une implantation du module Réseau 
                utilisant une technique sans serveur.</para>

                <para>Le namespace correspondant est 
                <classname>ProjetUnivers::Reseau::Implantation::Distribue</classname>.</para>

              </listitem>

            </itemizedlist>

          </example>

        </sect4>

      </sect3>

    </sect2>

    <sect2>

      <title>Fichiers sources</title>

      <para>Les fichiers <filename>.h</filename> contiennent les 
      définition des classes, les <filename>.cpp</filename> leur 
      implantation.</para>

      <para>Pour chaque classe on a un fichier <filename>.h</filename> 
      et éventuellement un fichier <filename>.cpp</filename>. Les noms 
      des fichiers d&apos;une classe 
      <classname>MerveilleDeLUnivers</classname> sont <filename>
      merveille_de_l_univers.h</filename> et <filename>
      merveille_de_l_univers.cpp</filename>.</para>

      <para>Les fichiers <filename>.h</filename> doivent contenir un 
      code de préprocesseur C qui permet d&apos;éviter les inclusions 
      multiples. Il doit englober tout le code du <filename>
      .h</filename> et est de la forme suivante :</para>

      <programlisting>#ifndef MERVEILLE_DE_L_UNIVERS_H
#define MERVEILLE_DE_L_UNIVERS_H

....

#endif</programlisting>
      <para>Les lignes de code dans les fichiers ne doivent pas 
      dépasser 80 colonnes.</para>

    </sect2>

    <sect2>

      <title>Inclusions et définitions en avant</title>

      <para>Pour compiler un <filename>.h</filename> , il convient 
      d&apos;utiliser d&apos;autres fichiers et de définir certaines 
      classes en avant. La règle est la suivante : on n&apos;inclus que 
      les fichiers <filename>.h</filename> des classes qui sont 
      héritées, des classes de valeurs utilisées ou des classes 
      templates. Les inclusions prennent la forme suivante :</para>

      <para>

        <programlisting>#include &lt;module/sous_module/fichier&gt;</programlisting>
      </para>

      <para>Ceci à pour but de n&apos;avoir qu&apos;un seul répertoire 
      racine des inclusions comme option de compilation.</para>

      <para>

        Pour chaque classe d&apos;objets O, une déclaration
        <programlisting>class O ; </programlisting>
        suffit.
      </para>

    </sect2>

    <sect2>

      <title>Nommage et commentaires</title>

      <sect3>

        <title>Le nommage</title>

        <para>La structure des noms de namespace, classes, types, 
        attributs, méthodes, variables est une suite de mots en 
        français, sans abréviation, avec une majuscule comme séparation 
        entre les mots.</para>

        <para>Les classes et les types commencent pas une majuscule, 
        les attributs, variables méthodes, procédures pas une 
        minuscule.</para>

        <para>Les noms des paramètres d&apos;une méthodes commencent 
        par <token>_</token>.</para>

        <example>

          <title>Exemples de noms</title>

          <para><classname>Reseau</classname></para>

          <para><varname>estPresent</varname></para>

          <para><classname>ObjetAPositionApprochee</classname></para>

          <para><parameter>_nouvelAge</parameter></para>

        </example>

        <para>Tout comme les commentaires, le nom d&apos;un concept C++ 
        doit indiquer ce que représente l&apos;élément par rapport au 
        monde dont on parle. Par exemple, Reseau est le nom d&apos;une 
        classe dont les objets représentent des réseaux 
        d&apos;ordinateurs.</para>

        <para>Un nom peut être composée d&apos;une phrase en français 
        qui explicie les propriétés importantes de ses objets. Par 
        exemple, les objets de la classe ObjetAPositionApprochee sont 
        des objets dont la position ne peut être estimée que de manière 
        approchée.</para>

        <para>Les phrases de français ne sont pas tout à fait les mêmes 
        en fonction de la nature de l&apos;élément C++ :</para>

        <itemizedlist>

          <listitem>

            <para>Les noms des namespaces sont des groupes 
            nominaux</para>

          </listitem>

          <listitem>

            <para>Les noms des classes sont des groupes nominaux</para>

          </listitem>

          <listitem>

            <para>Les noms des méthodes sont des groupes verbaux</para>

          </listitem>

          <listitem>

            <para>Les noms des attributs sont des groupes 
            adjectivaux?</para>

          </listitem>

        </itemizedlist>

      </sect3>

      <sect3>

        <title>Les commentaires</title>

        <para>Nombre de gens s&apos;accordent pour dire que les 
        commentaires dans un code source sont essentiels. La question 
        est alors de savoir quoi mettre comme commentaires. Les 
        commentaires ne doivent pas être une &quot;réformulation&quot; 
        du code qu&apos;ils commentent. Il faut par exemple éviter de 
        rappeler le type d&apos;une variable dans son commentaire. 
        D&apos;une manière générale le commentaire doit être utile, si 
        on peut déduire le commentaire du morceau de code qu&apos;il 
        commente alors c&apos;est qu&apos;il n&apos;est pas très 
        utile.</para>

        <para>Les commentaires commencent généralement par 
        <token>///</token> sauf pour certains commentaires qui 
        utilisent <token>/*! ...*/</token>.</para>

        <para>Un commentaire doit être le plus court possible et 
        expliquer quel sens possède le morceau de code par rapport à 
        l&apos;idée générale du programme. Pour ecrire un commentaire 
        la question à se poser est : &quot;qu&apos;est-ce que 
        représente cette chose ?&quot; et surtout pas : &quot;comment 
        c&apos;est fait ?&quot;.</para>

        <para>Dans le cas du projet univers, le monde imaginaire est un 
        monde de vaisseaux, de pilotes, de planetes, etc... Un 
        commentaire doit indiquer ce que l&apos;élément C++ (classe, 
        etc..) représente dans ce monde. Par exemple, le commentaire 
        associé à une classe appelée <classname>Vaisseau</classname> 
        sera tout simplement &quot;Un vaisseau&quot;!</para>

        <para>Les commentaires suivent une certaine syntaxe ce qui 
        permet d&apos;extraire ces commentaires vers des pages html. 
        L&apos;outil <ulink url="http://www.stack.nl/~dimitri/doxygen/">
        Doxygen</ulink> permet de lire des fichiers source et d&apos;en 
        extraire les descriptions de classes et les commentaires.</para>

        <para>En général, les commentaires sont inutiles surtout 
        lorsque le nom de l&apos;objet a été bien choisi. Cependant, 
        certains commentaires sont obligatoires :</para>

        <itemizedlist>

          <listitem>

            <para>Les commentaires de classe, qui précisent ce que 
            représentent les objets de la classe et les diverses façons 
            d&apos;utiliser la classe.</para>

            <para>Ils précèdent le mot réservé C++ <token>class</token> 
            et sont de la forme suivante :</para>

            <programlisting>/// Courte description de la classe.

/*!
  Description détaillée
*/
class NomDeLaClasse ...</programlisting>
          </listitem>

          <listitem>

            <para>Les commentaires d&apos;attributs, qui précisent ce 
            que représente cet attribut.</para>

            <para>Ils précèdent la déclaration d&apos;attribut et sont 
            de la forme suivante :</para>

            <programlisting>/// Age de l&apos;objet
Entier age ;</programlisting>
          </listitem>

          <listitem>

            <para>Les commentaires de méthodes, qui précisent ce que 
            fait la méthode.</para>

            <para>Ils précédent la déclaration de la méthode et sont de 
            la forme suivante :</para>

            <programlisting>/// Change l&apos;age de l&apos;objet par _nouvelAge
/// Si ce nouvel age est négatif, lève l&apos;exception ExceptionAgePasBon.
void changerAge(const Entier&amp; _nouvelAge) ;</programlisting>
            <para>La première ligne doit contenir au moins 10 
            caractères <token>/</token>.</para>

          </listitem>

        </itemizedlist>

        <para />

        <para>Une description détaillée pourra indiquer dans quel 
        aspect de l&apos;application la classe est utilisée. Doxygen 
        propose un grand nombre de <ulink>tags</ulink> permettant de 
        définir des sous-sections particulières d&apos;une description 
        détaillée.</para>

        <para>On pourra notamment utiliser ls tags suivants :</para>

        <itemizedlist>

          <listitem>

            <para>@example ou \example</para>

            <para>qui permet de définir un example</para>

          </listitem>

          <listitem>

            <para>@todo ou \todo</para>

            <para>qui decrit ce qu&apos;il reste à faire</para>

          </listitem>

          <listitem>

            <para>@remark ou \remark</para>

            <para>qui permet d&apos;indiquer des remarques</para>

          </listitem>

        </itemizedlist>

        <para>D&apos;autres commentaires sont par contre 
        non-obligatoires mais fortement recommandés :</para>

        <itemizedlist>

          <listitem>

            <para>Les commentaires de regroupements de membres de 
            classes.</para>

            <para>Il n&apos;est pas rare que dans une classe un 
            ensemble de méthodes soient faites pour être utilisées dans 
            le même contexte. Conceptuellement, ce genre de regoupement 
            doit correspondre à une façon d&apos;utiliser les objets de 
            la classe. Par exemple, imaginons que l&apos;application 
            ait 3 étapes distinctes, une phase d&apos;initialisation, 
            une phase d&apos;utilisation et enfin une phase de 
            finalisation : chaque classe se verrait attribuer des 
            méthodes pour chacune de ces phases, méthodes qui seraient 
            regroupées par phases. Notez que ce système ne permet pas à 
            2 groupes de partager une méthode.</para>

            <para>Il est possible de les &quot;distinguer&quot; des 
            autres membres à l&apos;aide du commentaire de 
            regroupement, qui est de la forme suivante :</para>

            <programlisting>// ******************************************
/// @name Initialisation d&apos;une partie
// ******************************************
// @{

....


// @}</programlisting>
            <para>Les lignes 1 et 3 ne sont pas obligatoires, elles 
            n&apos;ont pour but que de bien séparer les différents 
            groupes. Les caractère @{ et @} servent à délimitter le 
            groupe. Les groupes peuvent être imbiqués.</para>

            <example>

              <title>D&apos;autres exemples</title>

              <programlisting>// ***************************************
/// @name Utilisation en cours de jeu
// ***************************************
// @{
...

// @}
// **************************************
/// @name Finalisation
// **************************************
// @{</programlisting>
            </example>

          </listitem>

          <listitem>

            <para>Les commentaires dans l&apos;implantation pour 
            préciser les principales étapes d&apos;un gros 
            algorithme.</para>

            <para>Ces commentaires ne sont pas traités automatiquement 
            par des outils, ils sont juste là pour les programmeurs. 
            Ils doivent précéder ce qu&apos;ils commentent.</para>

          </listitem>

        </itemizedlist>

        <para>Enfin, les commentaires doivent être écrits en même temps 
        que ce qu&apos;ils commentent, même si cette règle est presque 
        invérifiable.</para>

      </sect3>

    </sect2>

    <sect2>

      <title>Modélisation orientée-objet</title>

      <para>Les règles de cette section définissent quelle doit être la 
      structure des diagrammes de classes dans un langage comme 
      C++.</para>

      <para>L&apos;idée générale est de faire correspondre le monde 
      imaginaire et le programme. Dans le cas du projet univers, le 
      monde imaginaire est un monde de vaisseaus, de pilotes, de 
      planetes, etc...</para>

      <sect3>

        <title>Une classe est un ensemble d&apos;objets du monde</title>

        <para>Une classe représente un ensemble d&apos;objets du monde 
        imaginaire que simule le programme.</para>

        <para>Les classes concrètes modélisent des ensembles 
        d&apos;objets du monde qui sont disjointes deux à deux et qui 
        sont rigides, i.e., une fois qu&apos;on y est on y reste.</para>

        <para>L&apos;exemple suivant illustre la disjonction des 
        classes &quot;feuilles&quot; dans un arbre 
        d&apos;héritage.</para>

        <example>

          <title>Classes feuilles disjointes</title>

          <para />

        </example>

        <para>Il faut faire très attention car une fois un objet C++ 
        construit dans une classe, il ne peut changer de classe. Donc 
        chaque classe doit représenter un ensemble d&apos;objets du 
        monde qui ne peuvent en sortir. Ainsi, définir une classe de 
        personnes jeunes ne marche pas si ces personnes peuvent devenir 
        vieilles : il faudrait alors que l&apos;objet C++ 
        &quot;sorte&quot; de la classe.</para>

      </sect3>

      <sect3>

        <title>Trois types de classes</title>

        <para>Chaque classe doit être soit une classes de valeurs, soit 
        une classe abstraite d&apos;objets soit une classe concrète 
        d&apos;objets.</para>

        <para>Les seules classes pour lesquelles on écrit un 
        destructeur sont les classe d&apos;objets abstraites. Pour 
        toutes les autres le destructeur par défaut suffit.</para>

      </sect3>

      <sect3>

        <title>Héritage Public</title>

        <para>Tous les héritages doivent être publics. Il est possible 
        que quelques héritages &quot;virtuels&quot; soient 
        nécessaires.</para>

      </sect3>

      <sect3>

        <title>Héritage de classes abstraites</title>

        <para>Toutes les classes parentes d&apos;une classe doivent 
        être abstraites.</para>

      </sect3>

      <sect3>

        <title>Les classes abstraites ont des constructeurs protégés et 
        un destructeur virtuel non pur</title>

        <para>Les classes abstraites ne peuvent être construites car 
        elles possèdent une méthode virtuelle pure (i.e., sans code). 
        Toute construction d&apos;un objet d&apos;une classe abstraite 
        qui n&apos;est pas un objet d&apos;une sous-classe concrète 
        entraine une erreur de liaison à la compilation. Le 
        constructeur doit donc être &quot;protected&quot;, pour pouvoir 
        quand même être appelé par les sous-classes.</para>

        <para>L&apos;intérêt d&apos;une classe abstraite est que la 
        grande majorité des références aux objets de ses sous-classes 
        se feront à travers des références à cette classe abstraite. Le 
        constructeur doit donc être virtuel pour que le bon 
        constructeur soit appelé, non pur pour des raisons C++.</para>

      </sect3>

    </sect2>

    <sect2>

      <title>Règles sur C++</title>

      <para>C++ hérite de C tout une panoplie de possibilités. 
      Certaines sont pratiques et d&apos;autres des nids à bugs.</para>

      <sect3>

        <title>Une instruction par ligne</title>

        <para>Chaque ligne doit contenir une seule instruction. Par 
        exemple, les déclarations de variables ne déclarent pas 
        plusieurs variables sur la même ligne. Les instructions C++ 
        sont :</para>

        <itemizedlist>

          <listitem>

            <para>

              une déclaration de variable :
              <programlisting>Entier nombreDeCopains = 0 ;</programlisting>
            </para>

          </listitem>

          <listitem>

            <para>une affectation :</para>

            <programlisting>nombreDeCopains = 7 ;
nombreDeCopains += 3 ;</programlisting>
          </listitem>

          <listitem>

            <para />

          </listitem>

          <listitem>

            <para>un appel de méthode/procédure :</para>

            <para />

          </listitem>

          <listitem>

            <para>un test :</para>

          </listitem>

          <listitem>

            <para>une boucle while :</para>

          </listitem>

          <listitem>

            <para>une boucle for :</para>

          </listitem>

          <listitem>

            <para>un return :</para>

          </listitem>

          <listitem>

            <para>un try catch :</para>

          </listitem>

        </itemizedlist>

        <para>Toutes les instructions de contrôles doivent être suivies 
        d&apos;un block { } même si ce block ne contient qu&apos;une 
        seule instruction.</para>

      </sect3>

      <sect3>

        <title>Pas de constantes drectement dans le code</title>

        <para>Toutes les valeurs constantes devant se trouver dans le 
        code doivent être soit définies comme constantes C++ soit comme 
        constantes à l&apos;aide du préprocesseur.</para>

        <example>

          <title>Exemples de constantes</title>

          <programlisting>#define TAILLE_DES_PAQUETS 134
const Entier LongeurMaximumDesChaines = 189 ;</programlisting>
        </example>

      </sect3>

      <sect3>

        <title>Classes C++</title>

        <para>Les modifieurs <token>public</token>, 
        <token>protected</token>, <token>private</token> sont spécifiés 
        dans cet ordre et sont obligatoirement précisés.</para>

        <example>

          <title>Exemple de classe</title>

          <programlisting>class Exemple
{
public:
  ...
protected:
  ...
private:
  ...
}</programlisting>
          <para>Une classe d&apos;objet dont les objets ne doivent pas 
          être répliqués ne possède pas de constructeur de copie 
          public. Une solution pour l&apos;interdire est de déclarer un 
          constructeur de copie privé, de ne pas lui associer de code 
          et de préciser qu&apos;il est interdit de copier 
          l&apos;objet. Il existe en effet des cas où on désire 
          interdire de copier un objet, par exemple, les objets de la 
          classe Reseau ne peuvent être copiés.</para>

        </example>

      </sect3>

      <sect3>

        <title>Modifiabilité</title>

        <para>Les méthodes qui ne modifient pas l&apos;objet receveur 
        doivent être specifiées <token>const</token>.</para>

      </sect3>

    </sect2>

    <sect2>

      <title>Règles sur les types</title>

      <para>Le C++ étant une extension de C, il hérite à la fois ses 
      bons cotés et ses mauvais cotés. la notation [ ] notamment est 
      complétement dépassée tant elle est délicate à utiliser pour la 
      gestion de mémoire. Pour définir un tableau, il faut utiliser un 
      des types génériques de tableau. En fonction de l&apos;objectif 
      et de la situation il convient d&apos;utiliser certains types 
      plutôt que d&apos;autres.</para>

      <para>Ces règles sont très contraignantes. Elles ont 
      essentiellement deux objectifs :</para>

      <itemizedlist>

        <listitem>

          <para>Supprimer les fuites de mémoires.</para>

          <para>L&apos;expliciation de la différence entre composition 
          et association, qui existent tous deux en UML, ainsi que les 
          règles ci-dessous permettent de supprimer totalement les 
          fuites de mémoire.</para>

        </listitem>

        <listitem>

          <para>Expliciter la façon dont on manipule les choses.</para>

          <para>La différence objet/valeur et mono-valué/multi-valué 
          permet de préciser de quoi on parle.</para>

        </listitem>

      </itemizedlist>

      <para>Ces règles sont la partie la plus importante de ce 
      document.</para>

      <sect3>

        <title>Les attributs de classes et les variables</title>

        <para>Soit O et O&apos; deux classes d&apos;objets et V une 
        classe de valeurs, les différents types des variables et des 
        attributs possibles sont les suivants :</para>

        <itemizedlist>

          <listitem>

            <para>V</para>

          </listitem>

          <listitem>

            <para>Base::Association&lt; O &gt;</para>

          </listitem>

          <listitem>

            <para>Base::Composition&lt; O &gt;</para>

          </listitem>

          <listitem>

            <para>Base::EnsembleValeur&lt; V &gt;</para>

          </listitem>

          <listitem>

            <para>Base::EnsembleAssociation&lt; O &gt;</para>

          </listitem>

          <listitem>

            <para>Base::EnsembleComposition&lt; O &gt;</para>

          </listitem>

          <listitem>

            <para>Base::FonctionObjetValeur&lt; O, V &gt;</para>

          </listitem>

          <listitem>

            <para>Base::FonctionValeurValeur&lt; V, V&apos; &gt;</para>

          </listitem>

          <listitem>

            <para>Base::FonctionCompositionObjetObjet&lt; O, O&apos; 
            &gt;</para>

          </listitem>

          <listitem>

            <para>Base::FonctionCompositionValeurObjet&lt; V, O 
            &gt;</para>

          </listitem>

          <listitem>

            <para>Base::FonctionAssociationObjetObjet&lt; O, O&apos; 
            &gt;</para>

          </listitem>

          <listitem>

            <para>Base::FonctionAssociationValeurObjet&lt; V, O 
            &gt;</para>

          </listitem>

        </itemizedlist>

        <para>Pour choisir entre ces différents types il a trois 
        questions à se poser :</para>

        <itemizedlist>

          <listitem>

            <para>Y a t-il un ou plusieurs objets référencés ?</para>

            <example>

              <title>Exemples</title>

              <para>Une voiture possède 4 roues, on utilisera donc un 
              type EnsembleXXX&lt; Roue &gt; comme type de 
              l&apos;attribut roues dans la classe voiture.</para>

              <para>Par contre une voiture n&apos;à qu&apos;un seul 
              volant, on utilisera donc soit une classe de valeur 
              volant, soit une association soit une composition.</para>

            </example>

          </listitem>

          <listitem>

            <para>Ces objets sont-ils des composants de l&apos;objet 
            qui les référence ?</para>

            <para>Un objet x est composant d&apos;un objet o s&apos;il 
            est une partie constituante de l&apos;objet o (la partie x 
            doit être détruite si on détruit l&apos;objet o).</para>

            <example>

              <title>Exemple de composition</title>

              <para>Une roue est une partie d&apos;une voiture, il y a 
              4 roues, donc on mettra un attribut de type 
              Base::EnsembleComposition&lt; Roue &gt; dans la classe 
              Voiture.</para>

            </example>

          </listitem>

          <listitem>

            <para>Est-ce que les éléments sont indicés par 
            d&apos;autres éléments ?</para>

            <para>La question est de savoir si oSoit O et O&apos; deux 
            classes d&apos;objets et V une classe de valeurs, n veut 
            quelque chose qui ressemble à un tableau, ou à une 
            fonction, au sens mathématique. Un tableau de T est une 
            fonction des entiers entre 0 et n vers T.</para>

            <example>

              <title>Exemple de fonction</title>

              <para>Chaque conducteur de la voiture a déjà conduit 
              cette voiture un certain nombre de fois. On mettra alors 
              un attribut de type FonctionObjetValeur&lt; Conducteur, 
              Entier &gt; dans la classe voiture pour modéliser la 
              fonction qui à chaque conducteur associe le nombre de 
              fois qu&apos;il a conduit cette voiture. Remarquez 
              qu&apos;on aurait pu mettre une autre fonction modélisant 
              la même notion dans la classe Conducteur.</para>

            </example>

          </listitem>

        </itemizedlist>

        <para>Très exceptionnellement, on pourra aussi utiliser des 
        types de listes, mais ceci devra être très ponctuel, et il 
        faudra alors justifier que l&apos;ordre des éléments est 
        vraiement important. On utilisera alors :</para>

        <itemizedlist>

          <listitem>

            <para>Base::Implantation::ListeValeur&lt; V &gt;</para>

          </listitem>

          <listitem>

            <para>Base::Implantation::ListeAssociation&lt; O &gt;</para>

          </listitem>

          <listitem>

            <para>Base::Implantation::ListeComposition&lt; O &gt;</para>

          </listitem>

        </itemizedlist>

        <para>En général c&apos;est une mauvaise idée d&apos;utiliser 
        une liste car cela peut être remplacé par une fonction des 
        entiers vers les éléments.</para>

        <para>Les types génériques ci-dessus ne sont pas imbriqués les 
        uns dans les autres : pas de listes de listes ou 
        d&apos;ensemble d&apos;ensembles. Ceci n&apos;entrave en rien 
        le pouvoir d&apos;expression, il suffit de rajouter une classe 
        intermédiaire.</para>

      </sect3>

      <sect3>

        <title>Les paramètres des méthodes</title>

        <para>Soit O et O&apos; deux classes d&apos;objets et V une 
        classe de valeurs, les paramètres des méthodes doivent être 
        d&apos;un des différents types suivants :</para>

        <itemizedlist>

          <listitem>

            <para>const V&amp;</para>

          </listitem>

          <listitem>

            <para>const Base::Association&lt; O &gt;&amp;</para>

          </listitem>

          <listitem>

            <para>O*</para>

            <para>ce type permet de passer en paramètre un objet 
            qu&apos;on vient de construire et qui n&apos;est pas encore 
            le composant d&apos;un objet</para>

          </listitem>

          <listitem>

            <para>const Base::EnsembleAssociation&lt; O &gt;&amp;</para>

          </listitem>

          <listitem>

            <para>const Base::EnsembleValeur&lt; V &gt;&amp;</para>

          </listitem>

          <listitem>

            <para>const Base::FonctionObjetValeur&lt; O, V 
            &gt;&amp;</para>

          </listitem>

          <listitem>

            <para>const Base::FonctionValeurValeur&lt; V, V&apos; 
            &gt;&amp;</para>

          </listitem>

          <listitem>

            <para>const Base::FonctionAssociationObjetObjet&lt; O, 
            O&apos; &gt;&amp;</para>

          </listitem>

          <listitem>

            <para>const Base::FonctionAssociationValeurObjet&lt; V, O 
            &gt;&amp;</para>

          </listitem>

        </itemizedlist>

        <para>La règle générale est que le plus possible des paramètres 
        sont passé en const T&amp;, pour des raisons 
        d&apos;optimisation de C++. Ensuite, une composition ne peut 
        être passée en paramètre. Le type pointeur sur classe 
        d&apos;objet O* sert à donner la responsabilité d&apos;un objet 
        à quelqu&apos;un. C&apos;est d&apos;ailleurs le type du 
        paramètre de Ajouter dans Base::EnsembleComposition&lt; O 
        &gt;.</para>

      </sect3>

      <sect3>

        <title>Types de retours des méthodes</title>

        <para>Soit O et O&apos; deux classes d&apos;objets et V une 
        classe de valeurs, les types de retours des méthodes doivent 
        être d&apos;un des différents types suivants :</para>

        <itemizedlist>

          <listitem>

            <para>V</para>

          </listitem>

          <listitem>

            <para>O*</para>

          </listitem>

          <listitem>

            <para>Base::Association&lt; O &gt;</para>

          </listitem>

          <listitem>

            <para>Base::EnsembleAssociation&lt; O &gt;</para>

          </listitem>

          <listitem>

            <para>Base::EnsembleValeur&lt; V &gt;</para>

          </listitem>

          <listitem>

            <para>Base::FonctionObjetValeur&lt; O, V &gt;</para>

          </listitem>

          <listitem>

            <para>Base::FonctionValeurValeur&lt; V, V&apos; &gt;</para>

          </listitem>

          <listitem>

            <para>Base::FonctionAssociationObjetObjet&lt; O, O&apos; 
            &gt;</para>

          </listitem>

          <listitem>

            <para>Base::FonctionAssociationValeurObjet&lt; O, O&apos; 
            &gt;</para>

          </listitem>

        </itemizedlist>

        <para>Le type de retours O* sert aux fonctions 
        &quot;fabriquante&quot;. C&apos;est notamment le type de 
        retours des constructeurs, fonctions fabriquantes par 
        excellence.</para>

      </sect3>

    </sect2>

    <sect2>

      <title>La programmation orientée évenements</title>

      <para>Ogre est orienté évennement, c&apos;est à dire qu&apos;à 
      chaque fois qu&apos;un évenement précis se produit, une opération 
      programmable est effectuée. Il s&apos;agit alors de dire quels 
      sont les événements auxquels on s&apos;interesse et ce qu&apos;il 
      faut faire</para>

      <para>TODO</para>

    </sect2>

  </sect1>

  <sect1>

    <title>Les test</title>

    <para>Les tests dits unitaires permettent de garantir qu&apos;un 
    code source contient peu de boggues.</para>

    <sect2>

      <title>Outil</title>

      <para>L&apos;outil utilisé pour les test est <ulink url="???">
      Cppunit</ulink>. Cette biliothèque C++ permet d&apos;automatiser 
      le lancement des tests. La mise en place d&apos;une série de test 
      pour un module <replaceable>nom de module</replaceable> est assez 
      simple :</para>

      <procedure><step><para>Recopier le répértoire ... à 
      l&apos;intérieur du répértoire correspondant au module 
      <replaceable>nom de module</replaceable>.</para></step>
      <step><para>Construire un module correspondant à ce répertoire. 
      Le nom du module de test est Test_<replaceable>nom de 
      module</replaceable>.</para></step><step><para>Ajouter des 
      classes de test dans ce module.</para></step></procedure>
    </sect2>

    <sect2>

      <title>Exemple de classe de test</title>

      <para />

      <example>

        <title>Exemple d&apos;une classe de test</title>

        <para>Une classe qui teste une autre classe. Le <filename>
        .h</filename>.</para>

        <programlisting>// test_reseau.h

#ifndef _RESEAU_TEST_TEST_RESEAU_H_
#define _RESEAU_TEST_TEST_RESEAU_H_

// CppUnit
#include &lt;cppunit/extensions/HelperMacros.h&gt;


namespace Reseau {

  namespace Test {

    /// Teste quelque chose.
    class TestReseau : public CppUnit::TestFixture {
    protected:

  
    // ****************************
    /// @name Tests proprement dits
    // ****************************
    // @{

  
      /// Teste la création d&apos;une partie
      void testCreerPartie() ;

      ...


    // @}
    // ********************
    /// @name Mise en place
    // ********************
    // @{


      CPPUNIT_TEST_SUITE() ;

      /// chaque procédure de test doit être &quot;enregistrée&quot;
      CPPUNIT_TEST(testCreerPartie) ;

      CPPUNIT_TEST_SUITE_END() ;

    public:

      /// Initialisation du test
      void setUp() ;

      /// Desinitialisation du test
      void tearDown() ;


      // @}

    private:

      /// ici on met les données du test
    };

  }
}
#endif // _RESEAU_TEST_TEST_RESEAU_H_</programlisting>
        <para>Le <filename>.cpp</filename> :</para>

        <programlisting>// test_reseau.cpp

#include &lt;reseau/test/test_reseau.h&gt;

// la classe de test est enregistrée
CPPUNIT_TEST_SUITE_REGISTRATION(TestReseau) ;  

namespace Reseau {

  namespace Test {

    void TestReseau::setUp()
    {
      // 
    }

    void TestReseau::tearDown()
    {
      // 
    }
  }
}</programlisting>
      </example>

    </sect2>

  </sect1>

  <sect1>

    <title>Outils de développements pour C++</title>

    <sect2>

      <title>Multi-plateforme</title>

      <para>Sous linux et windows vous pouvez utiliser 
      <ulink url="http://www.eclipse.org/">Eclipse</ulink> version 3.x 
      qui est un IDE doté de nombreuses extensions utiles :</para>

      <itemizedlist>

        <listitem>

          <para>
          <ulink url="http://www.eclipse.org/cdt/">CDT</ulink></para>

          <para>une extension eclipse pour le langage C++</para>

        </listitem>

        <listitem>

          <para>
          <ulink url="http://subclipse.tigris.org/">Subclipse</ulink></para>

          <para>une extension eclipse pour subversion</para>

          <para>Utile pour la gestion des fichiers partagés</para>

        </listitem>

        <listitem>

          <para>
          <ulink url="http://vex.sourceforge.net/install.html">Vex</ulink></para>

          <para>une extension eclipse pour DocBook</para>

          <para>Utile pour la rédaction de documents.</para>

        </listitem>

        <listitem>

          <para><ulink>Eclox</ulink></para>

          <para>une extension eclipse pour Doxygen (extracteur de 
          documentation des sources)</para>

        </listitem>

      </itemizedlist>

    </sect2>

    <sect2>

      <title>Sous Windows</title>

      <sect3>

        <title>Dev C++</title>

        <para><ulink url="http://www.bloodshed.net/dev/index.html">Dev 
        C++</ulink> est un environnement de développement C++ open 
        source. Il utilise classiquement <ulink url="???">Mingw</ulink> 
        comme compilateur, qui est un portage de gcc, mais il est 
        possible de lui imposer l&apos;utilisation d&apos;autres 
        compilateurs.</para>

        <para>Dev C++ possède un système de devpacks, dont notament un 
        pour 
        <ulink url="http://homepage.ntlworld.com/rob_edwards/Ogre.DevPackage">
        Ogre</ulink> et un pour 
        <ulink url="http://homepage.ntlworld.com/rob_edwards/Devil.DevPackage">
        Devil</ulink> une bibliothèque dont dépend Ogre.</para>

      </sect3>

    </sect2>

    <sect2>

      <title>Sous Linux</title>

      <para>Automake/Autoconf et gcc.</para>

    </sect2>

  </sect1>

  <glossary>

    <glossdiv>

      <title>Glossaire des termes</title>

      <glossentry>

        <glossterm>Developpeur</glossterm>

        <glossdef>

          <para>Personne ecrivant du code source sur le projet.</para>

        </glossdef>

      </glossentry>

      <glossentry>

        <glossterm>Code source</glossterm>

        <glossdef>

          <para>Texte</para>

        </glossdef>

      </glossentry>

      <glossentry>

        <glossterm>Valeur</glossterm>

        <glossdef>

          <para>Se dit d&apos;un objet C++ instance d&apos;une classe 
          de valeurs.</para>

        </glossdef>

      </glossentry>

      <glossentry>

        <glossterm>Objet C++</glossterm>

        <glossdef>

          <para>Un objet au sens de C++.</para>

        </glossdef>

      </glossentry>

      <glossentry>

        <glossterm>Objet</glossterm>

        <glossdef>

          <para>Un objet C++ qui est manipulé par référence.</para>

        </glossdef>

      </glossentry>

    </glossdiv>

    <bibliography>

      <bibliomixed>Bibliographie</bibliomixed>

      <biblioentry>

        <author><lineage>Mats Henricson</lineage></author>

        <author><lineage>Erik Nyquist</lineage></author>

        <title>
        <ulink url="http://www.doc.ic.ac.uk/lab/cplus/c++.rules/">Programming 
        in C++, Rules and Recommendations</ulink></title>

      </biblioentry>

      <biblioentry>

        <author><lineage>
        <ulink url="http://perso.club-internet.fr/philippe.prados/index.html">Philippe 
        Prados</ulink></lineage></author>

        <title>
        <ulink url="http://www.philippe.prados.name/Livre/QCPP/index.html">La 
        qualité en C++</ulink></title>

        <editor><lineage>Eyrolles</lineage></editor>
      </biblioentry>

    </bibliography>

  </glossary>

</article>

